---
title: "COBS for brainspan data"
output: html_document
date: "2023-11-13"
---


```{r, echo=F, message=F, warning=F, results=F}
######## replicating the results 
###https://github.com/linnykos/covarianceSelection

# install dependent packages 

#install.packages("doMC", repos="http://R-Forge.R-project.org")
library("doMC")

# if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("org.Hs.eg.db")
library("org.Hs.eg.db")

#download gz file to local folder and install https://cran.r-project.org/src/contrib/Archive/dequer/
library(dequer)


library("devtools")
devtools::install_github("linnylin92/covarianceSelection", subdir = "covarianceSelection")

```



```{r, echo=F, message=F, warning=F, eval=F}
# step0_loading.R  https://github.com/linnykos/covarianceSelection/blob/master/main/step0_loading.R
# step0_loading.R loads the BrainSpan dataset and TADA dataset (i.e., matching the genes in both datasets, resolving gene synonyms, removing genes not expressed in the brain).

if(verbose) print("Start of step 0: Loading")

#format the brainspan dataset
#load("../../raw_data/newGenexp.RData")
load("C:/han/Dataset/20231006_PMID_33731968/NIHMS1598069-supplement-Supp_1/newGenexp.RData")
rownames(genexp) <- genexp[,1]
genexp <- genexp[,-1]
genexp <- t(genexp)
genexp <- as.data.frame(genexp) # 1340 x 16947

#determine brain-expressed genes
brain_expression <- covarianceSelection::brain_expression
brain_genes <- brain_expression$Gene[brain_expression$Brain_expressed != 'No']
idx <- which(colnames(genexp) %in% brain_genes)
genexp <- genexp[,idx] # 1340 x 14370

#translate into synonyms
vec <- covarianceSelection::symbol_synonyms(colnames(genexp), verbose = T)
unknown_genes_idx <- which(is.na(vec))
vec <- vec[-unknown_genes_idx]
genexp <- genexp[-unknown_genes_idx] # 1340 x 14297
colnames(genexp) <- vec

#average non-unique genes
genexp <- covarianceSelection:::average_same_columns(genexp) # 1340 x 14246

#remove samples from subregions that we don't have a region for
region_subregion <- covarianceSelection::region_subregion
vec <- rownames(genexp)
subregion <- unlist(strsplit(vec,"\\."))[seq(2, length(vec)*4, 4)]
idx <- which(subregion %in% region_subregion$subregion)
genexp <- genexp[idx,] # 1294 x 14249

####

#load tada dataset
tada <- covarianceSelection::tada

#match the order in both datasets
idx <- which(colnames(genexp) %in% tada$Gene)
genexp <- genexp[,idx] # 1294 x 13964
idx <- which(tada$Gene %in% colnames(genexp))
tada <- tada[idx,] # 13964 genes
idx <- covarianceSelection::matching(tada$Gene, colnames(genexp))
genexp <- genexp[,idx]

dat_list <- covarianceSelection::extractor(genexp) # 212 partitions
dat_list <- lapply(dat_list, as.matrix, drop = F)

# remove partitions too small
idx <- which(sapply(dat_list, function(x){ifelse(nrow(x) >= 5, T, F)}))
dat_list <- dat_list[idx] # 125 partitions
dat_list <- lapply(dat_list, scale, scale = F)

if(verbose) print(paste0("Dimension of genexp is: ", paste0(dim(genexp), collapse = ", ")))

#cleanup
rm(list = c("brain_expression", "brain_genes", "idx", "vec", "region_subregion",
            "subregion", "genexp", "unknown_genes_idx"))

#save.image(file = paste0(save_filepath, "/step0_loading", filepath_suffix, ".RData"))

```



```{r, echo=F, message=F, warning=F, eval=F}
# step1_screening.R screens the genes according to Liu et al. (2015). This is reported in Section 6.1.
# https://github.com/linnykos/covarianceSelection/blob/master/main/step1_screening.R
p_thres_screening <- 0.01 
p_primary <- 0.1
num_genes <- 3500

###

if(verbose) print(paste0(Sys.time(), "Start of step 1: Screening"))

selected_idx <- grep("PFC\\.[3-5]", names(dat_list))
dat_pfc35 <- do.call(rbind, dat_list[selected_idx]) # 107 x 13964

screening_res <- covarianceSelection::screen(dat_pfc35, pv = tada$pval.TADA, p_thres = p_thres_screening, 
                                             num_genes = num_genes)

# 265 primary, 3235 secondary, total of 3500

# reorder which genes are primary and which are secondary
all_idx <- sort(unique(c(screening_res$primary, screening_res$secondary)))
screening_res$primary <- all_idx[which(tada$pval.TADA[all_idx] < p_primary)]
screening_res$secondary <- setdiff(all_idx, screening_res$primary)

# apply the new gene list
for(i in 1:length(dat_list)){
  dat_list[[i]] <- dat_list[[i]][,c(screening_res$primary, screening_res$secondary)]
}
tada <- tada[c(screening_res$primary, screening_res$secondary),]
                
if(verbose) print(paste0("Dimension of dat_list is: ", unique(sapply(dat_list, ncol)), collapse = ", "))

rm(list = c("selected_idx", "dat_pfc35", "i"))

#save.image(file = paste0(save_filepath, "/step1_screening", filepath_suffix, ".RData"))
```


```{r, echo=F, message=F, warning=F, eval=F}
fdr_cutoff_alt <- 0.1

if(verbose) print(paste0(Sys.time(), "Start of step 2: No DAWN analysis"))

genes_nodawn <- sort(as.character(tada[which(tada$qvalue <= fdr_cutoff_alt),"Gene"]))

#save.image(file = paste0(save_filepath, "/step2_nodawn_analysis", filepath_suffix, ".RData"))
```


```{r echo=F, message=F, warning=F, eval=F}
# step3_pfc35_analysis.R implicates risk genes in the DAWN framework using the Window 1B partitions. This is reported in Section 6.4.
# https://github.com/linnykos/covarianceSelection/blob/master/main/step3_pfc35_analysis.R
fdr_cutoff <- 0.01
pthres <- 0.05

#####
set.seed(10)
if(verbose) print(paste0(Sys.time(), "Start of step 3: Naive analysis"))

selected_idx <- grep("PFC\\.[3-5]", names(dat_list))
dat_pfc35 <- do.call(rbind, dat_list[selected_idx]) # 107 x 3065
dat_pfc35 <- scale(dat_pfc35, scale = F)

# estimate graphical model on PFC35 using cross-validated lasso for neighborhood selection
# res <- covarianceSelection::graphicalModel_range(dat_pfc35, 1:length(screening_res$primary), 
#                                                  lambda_min = 0.01, lambda_max = 0.35, 
#                                                  lambda_length = 30, verbose = T) 
# save.image(file = paste0(save_filepath, "/step3_pfc35_analysis", filepath_suffix, ".RData"))
# 
# scale_vec_pfc35 <- sapply(res, function(x){covarianceSelection::compute_scale_free(as.matrix(x$adj_mat))})
# edges_vec_pfc35 <- sapply(res, function(x){sum(as.matrix(x$adj_mat))/2})
# # idx <- which.max(scale_vec_pfc35)
# idx <- 27
# adj_pfc35 <- as.matrix(res[[idx]]$adj_mat)

res <- covarianceSelection::graphicalModel(dat_pfc35, primary_idx = 1:length(screening_res$primary), lambda = seq(0.05, 0.1, length.out = 15)[1])
adj_pfc35 <- as.matrix(res$adj_mat)
stopifnot(all(dim(adj_pfc35) == nrow(tada)))

# run the HMRF
set.seed(10)
seedindex <- rep(0, ncol(adj_pfc35))
seedindex[which(tada$dn.LoF >= 3)] <- 1

if(verbose) print(paste0(Sys.time(), ": HMRF"))
set.seed(10)
hmrf_pfc35 <- covarianceSelection::hmrf(tada$pval.TADA, adj_pfc35, seedindex, pthres = pthres)
report_pfc35 <- covarianceSelection::report_results(tada$Gene, 1-hmrf_pfc35$post, tada$pval.TADA, hmrf_pfc35$Iupdate)
genes_pfc35 <- sort(as.character(report_pfc35$Gene[which(report_pfc35$FDR <= fdr_cutoff)]))

adj_pfc35 <- Matrix::Matrix(adj_pfc35, sparse = T)

rm(list = c("dat_pfc35", "seedindex", "idx", "res", "selected_idx"))

#save.image(file = paste0(save_filepath, "/step3_pfc35_analysis", filepath_suffix, ".RData"))

########################

 #plot(exp(seq(log(0.01), log(0.35), length.out = length(scale_vec_pfc35))), scale_vec_pfc35)
```


```{r, echo=F, message=F, warning=F, eval=F}
# step4_subjectselection.R uses COBS and is the most computational-intensive part of our procedure. This selects the 24 partitions in BrainSpan that we report in our paper. This is reported in Section 6.2.
# https://github.com/linnykos/covarianceSelection/blob/master/main/step4_subjectselection.R
trials <- 100
prob_val <- 1-1e-5
stepdown_alpha <- 0.1

if(verbose) print(paste0(Sys.time(), "Start of step 5: Subject selection"))

set.seed(10)
stepdown_res <- covarianceSelection::stepdown(dat_list, trials = trials, alpha = stepdown_alpha, return_pvalue = F,
                                              prob = prob_val, verbose = T, cores = ncores)

#save.image(file = paste0(save_filepath, "/step4_subjectselection", filepath_suffix, ".RData"))
```


```{r, echo=F, message=F, warning=F, eval=F}
#step5_our_analysis.R implicates risk genes in the DAWN framework using our 24 partitions selected by COBS. This is reported in Section 6.4.
# https://github.com/linnykos/covarianceSelection/blob/master/main/step5_our_analysis.R
gamma_threshold <- 0.95

if(verbose) print(paste0(Sys.time(), "Start of step 6: Our data analysis"))

n <- length(dat_list)
g_selected <- igraph::graph.empty(n = n, directed = F)
combn_mat <- utils::combn(length(dat_list), 2)
g_selected <- igraph::add_edges(g_selected, edges = combn_mat[,stepdown_res$null_idx])

# construct the core set
selected_idx <- grep("PFC\\.[3-5]", names(dat_list))
g_sub <- igraph::induced_subgraph(g_selected, selected_idx)
core_set <- selected_idx[covarianceSelection::clique_selection(g_sub, threshold = gamma_threshold)[[1]]]
idx_our <- covarianceSelection::clique_selection(g_selected, threshold = gamma_threshold, target_idx = core_set)
idx_our <- idx_our[[1]]

dat_our <- do.call(rbind, dat_list[idx_our])
dat_our <- scale(dat_our, scale = F)

res <- covarianceSelection::graphicalModel(dat_our, primary_idx = 1:length(screening_res$primary), 
                                           lambda = seq(0.05, 0.1, length.out = 15)[5])
adj_our <- as.matrix(res$adj_mat)

# run the HMRF
set.seed(10)
seedindex <- rep( 0, ncol(adj_our))
seedindex[which(tada$dn.LoF >= 3)] <- 1

if(verbose) print(paste0(Sys.time(), ": HMRF"))
set.seed(10)
hmrf_our <- covarianceSelection::hmrf(tada$pval.TADA, adj_our, seedindex, pthres = pthres) 
report_our <- covarianceSelection::report_results(tada$Gene, 1-hmrf_our$post, tada$pval.TADA, hmrf_our$Iupdate)
genes_our <- sort(as.character(report_our$Gene[which(report_our$FDR <= fdr_cutoff)]))

adj_our <- Matrix::Matrix(adj_our, sparse = T)

rm(list = c("dat_our", "seedindex", "res", "combn_mat", "n", "g_selected", "g_sub", "selected_idx", "core_set"))

#save.image(file = paste0(save_filepath, "/step5_ourdata_analysis", filepath_suffix, ".RData"))
```